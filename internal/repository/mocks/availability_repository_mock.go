// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i application-design-test/internal/service.AvailabilityRepository -o availability_repository_mock.go -n AvailabilityRepositoryMock -p mocks

import (
	"application-design-test/internal/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AvailabilityRepositoryMock implements mm_service.AvailabilityRepository
type AvailabilityRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDecrementRoomQuota          func(ctx context.Context, hotelID string, roomID string, date []time.Time) (err error)
	funcDecrementRoomQuotaOrigin    string
	inspectFuncDecrementRoomQuota   func(ctx context.Context, hotelID string, roomID string, date []time.Time)
	afterDecrementRoomQuotaCounter  uint64
	beforeDecrementRoomQuotaCounter uint64
	DecrementRoomQuotaMock          mAvailabilityRepositoryMockDecrementRoomQuota

	funcGetRoomAvailability          func(ctx context.Context, hotelID string, roomID string) (d1 model.DateQuotaMap, err error)
	funcGetRoomAvailabilityOrigin    string
	inspectFuncGetRoomAvailability   func(ctx context.Context, hotelID string, roomID string)
	afterGetRoomAvailabilityCounter  uint64
	beforeGetRoomAvailabilityCounter uint64
	GetRoomAvailabilityMock          mAvailabilityRepositoryMockGetRoomAvailability
}

// NewAvailabilityRepositoryMock returns a mock for mm_service.AvailabilityRepository
func NewAvailabilityRepositoryMock(t minimock.Tester) *AvailabilityRepositoryMock {
	m := &AvailabilityRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DecrementRoomQuotaMock = mAvailabilityRepositoryMockDecrementRoomQuota{mock: m}
	m.DecrementRoomQuotaMock.callArgs = []*AvailabilityRepositoryMockDecrementRoomQuotaParams{}

	m.GetRoomAvailabilityMock = mAvailabilityRepositoryMockGetRoomAvailability{mock: m}
	m.GetRoomAvailabilityMock.callArgs = []*AvailabilityRepositoryMockGetRoomAvailabilityParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAvailabilityRepositoryMockDecrementRoomQuota struct {
	optional           bool
	mock               *AvailabilityRepositoryMock
	defaultExpectation *AvailabilityRepositoryMockDecrementRoomQuotaExpectation
	expectations       []*AvailabilityRepositoryMockDecrementRoomQuotaExpectation

	callArgs []*AvailabilityRepositoryMockDecrementRoomQuotaParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AvailabilityRepositoryMockDecrementRoomQuotaExpectation specifies expectation struct of the AvailabilityRepository.DecrementRoomQuota
type AvailabilityRepositoryMockDecrementRoomQuotaExpectation struct {
	mock               *AvailabilityRepositoryMock
	params             *AvailabilityRepositoryMockDecrementRoomQuotaParams
	paramPtrs          *AvailabilityRepositoryMockDecrementRoomQuotaParamPtrs
	expectationOrigins AvailabilityRepositoryMockDecrementRoomQuotaExpectationOrigins
	results            *AvailabilityRepositoryMockDecrementRoomQuotaResults
	returnOrigin       string
	Counter            uint64
}

// AvailabilityRepositoryMockDecrementRoomQuotaParams contains parameters of the AvailabilityRepository.DecrementRoomQuota
type AvailabilityRepositoryMockDecrementRoomQuotaParams struct {
	ctx     context.Context
	hotelID string
	roomID  string
	date    []time.Time
}

// AvailabilityRepositoryMockDecrementRoomQuotaParamPtrs contains pointers to parameters of the AvailabilityRepository.DecrementRoomQuota
type AvailabilityRepositoryMockDecrementRoomQuotaParamPtrs struct {
	ctx     *context.Context
	hotelID *string
	roomID  *string
	date    *[]time.Time
}

// AvailabilityRepositoryMockDecrementRoomQuotaResults contains results of the AvailabilityRepository.DecrementRoomQuota
type AvailabilityRepositoryMockDecrementRoomQuotaResults struct {
	err error
}

// AvailabilityRepositoryMockDecrementRoomQuotaOrigins contains origins of expectations of the AvailabilityRepository.DecrementRoomQuota
type AvailabilityRepositoryMockDecrementRoomQuotaExpectationOrigins struct {
	origin        string
	originCtx     string
	originHotelID string
	originRoomID  string
	originDate    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) Optional() *mAvailabilityRepositoryMockDecrementRoomQuota {
	mmDecrementRoomQuota.optional = true
	return mmDecrementRoomQuota
}

// Expect sets up expected params for AvailabilityRepository.DecrementRoomQuota
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) Expect(ctx context.Context, hotelID string, roomID string, date []time.Time) *mAvailabilityRepositoryMockDecrementRoomQuota {
	if mmDecrementRoomQuota.mock.funcDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Set")
	}

	if mmDecrementRoomQuota.defaultExpectation == nil {
		mmDecrementRoomQuota.defaultExpectation = &AvailabilityRepositoryMockDecrementRoomQuotaExpectation{}
	}

	if mmDecrementRoomQuota.defaultExpectation.paramPtrs != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by ExpectParams functions")
	}

	mmDecrementRoomQuota.defaultExpectation.params = &AvailabilityRepositoryMockDecrementRoomQuotaParams{ctx, hotelID, roomID, date}
	mmDecrementRoomQuota.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDecrementRoomQuota.expectations {
		if minimock.Equal(e.params, mmDecrementRoomQuota.defaultExpectation.params) {
			mmDecrementRoomQuota.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecrementRoomQuota.defaultExpectation.params)
		}
	}

	return mmDecrementRoomQuota
}

// ExpectCtxParam1 sets up expected param ctx for AvailabilityRepository.DecrementRoomQuota
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) ExpectCtxParam1(ctx context.Context) *mAvailabilityRepositoryMockDecrementRoomQuota {
	if mmDecrementRoomQuota.mock.funcDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Set")
	}

	if mmDecrementRoomQuota.defaultExpectation == nil {
		mmDecrementRoomQuota.defaultExpectation = &AvailabilityRepositoryMockDecrementRoomQuotaExpectation{}
	}

	if mmDecrementRoomQuota.defaultExpectation.params != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Expect")
	}

	if mmDecrementRoomQuota.defaultExpectation.paramPtrs == nil {
		mmDecrementRoomQuota.defaultExpectation.paramPtrs = &AvailabilityRepositoryMockDecrementRoomQuotaParamPtrs{}
	}
	mmDecrementRoomQuota.defaultExpectation.paramPtrs.ctx = &ctx
	mmDecrementRoomQuota.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDecrementRoomQuota
}

// ExpectHotelIDParam2 sets up expected param hotelID for AvailabilityRepository.DecrementRoomQuota
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) ExpectHotelIDParam2(hotelID string) *mAvailabilityRepositoryMockDecrementRoomQuota {
	if mmDecrementRoomQuota.mock.funcDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Set")
	}

	if mmDecrementRoomQuota.defaultExpectation == nil {
		mmDecrementRoomQuota.defaultExpectation = &AvailabilityRepositoryMockDecrementRoomQuotaExpectation{}
	}

	if mmDecrementRoomQuota.defaultExpectation.params != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Expect")
	}

	if mmDecrementRoomQuota.defaultExpectation.paramPtrs == nil {
		mmDecrementRoomQuota.defaultExpectation.paramPtrs = &AvailabilityRepositoryMockDecrementRoomQuotaParamPtrs{}
	}
	mmDecrementRoomQuota.defaultExpectation.paramPtrs.hotelID = &hotelID
	mmDecrementRoomQuota.defaultExpectation.expectationOrigins.originHotelID = minimock.CallerInfo(1)

	return mmDecrementRoomQuota
}

// ExpectRoomIDParam3 sets up expected param roomID for AvailabilityRepository.DecrementRoomQuota
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) ExpectRoomIDParam3(roomID string) *mAvailabilityRepositoryMockDecrementRoomQuota {
	if mmDecrementRoomQuota.mock.funcDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Set")
	}

	if mmDecrementRoomQuota.defaultExpectation == nil {
		mmDecrementRoomQuota.defaultExpectation = &AvailabilityRepositoryMockDecrementRoomQuotaExpectation{}
	}

	if mmDecrementRoomQuota.defaultExpectation.params != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Expect")
	}

	if mmDecrementRoomQuota.defaultExpectation.paramPtrs == nil {
		mmDecrementRoomQuota.defaultExpectation.paramPtrs = &AvailabilityRepositoryMockDecrementRoomQuotaParamPtrs{}
	}
	mmDecrementRoomQuota.defaultExpectation.paramPtrs.roomID = &roomID
	mmDecrementRoomQuota.defaultExpectation.expectationOrigins.originRoomID = minimock.CallerInfo(1)

	return mmDecrementRoomQuota
}

// ExpectDateParam4 sets up expected param date for AvailabilityRepository.DecrementRoomQuota
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) ExpectDateParam4(date []time.Time) *mAvailabilityRepositoryMockDecrementRoomQuota {
	if mmDecrementRoomQuota.mock.funcDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Set")
	}

	if mmDecrementRoomQuota.defaultExpectation == nil {
		mmDecrementRoomQuota.defaultExpectation = &AvailabilityRepositoryMockDecrementRoomQuotaExpectation{}
	}

	if mmDecrementRoomQuota.defaultExpectation.params != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Expect")
	}

	if mmDecrementRoomQuota.defaultExpectation.paramPtrs == nil {
		mmDecrementRoomQuota.defaultExpectation.paramPtrs = &AvailabilityRepositoryMockDecrementRoomQuotaParamPtrs{}
	}
	mmDecrementRoomQuota.defaultExpectation.paramPtrs.date = &date
	mmDecrementRoomQuota.defaultExpectation.expectationOrigins.originDate = minimock.CallerInfo(1)

	return mmDecrementRoomQuota
}

// Inspect accepts an inspector function that has same arguments as the AvailabilityRepository.DecrementRoomQuota
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) Inspect(f func(ctx context.Context, hotelID string, roomID string, date []time.Time)) *mAvailabilityRepositoryMockDecrementRoomQuota {
	if mmDecrementRoomQuota.mock.inspectFuncDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("Inspect function is already set for AvailabilityRepositoryMock.DecrementRoomQuota")
	}

	mmDecrementRoomQuota.mock.inspectFuncDecrementRoomQuota = f

	return mmDecrementRoomQuota
}

// Return sets up results that will be returned by AvailabilityRepository.DecrementRoomQuota
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) Return(err error) *AvailabilityRepositoryMock {
	if mmDecrementRoomQuota.mock.funcDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Set")
	}

	if mmDecrementRoomQuota.defaultExpectation == nil {
		mmDecrementRoomQuota.defaultExpectation = &AvailabilityRepositoryMockDecrementRoomQuotaExpectation{mock: mmDecrementRoomQuota.mock}
	}
	mmDecrementRoomQuota.defaultExpectation.results = &AvailabilityRepositoryMockDecrementRoomQuotaResults{err}
	mmDecrementRoomQuota.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDecrementRoomQuota.mock
}

// Set uses given function f to mock the AvailabilityRepository.DecrementRoomQuota method
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) Set(f func(ctx context.Context, hotelID string, roomID string, date []time.Time) (err error)) *AvailabilityRepositoryMock {
	if mmDecrementRoomQuota.defaultExpectation != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("Default expectation is already set for the AvailabilityRepository.DecrementRoomQuota method")
	}

	if len(mmDecrementRoomQuota.expectations) > 0 {
		mmDecrementRoomQuota.mock.t.Fatalf("Some expectations are already set for the AvailabilityRepository.DecrementRoomQuota method")
	}

	mmDecrementRoomQuota.mock.funcDecrementRoomQuota = f
	mmDecrementRoomQuota.mock.funcDecrementRoomQuotaOrigin = minimock.CallerInfo(1)
	return mmDecrementRoomQuota.mock
}

// When sets expectation for the AvailabilityRepository.DecrementRoomQuota which will trigger the result defined by the following
// Then helper
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) When(ctx context.Context, hotelID string, roomID string, date []time.Time) *AvailabilityRepositoryMockDecrementRoomQuotaExpectation {
	if mmDecrementRoomQuota.mock.funcDecrementRoomQuota != nil {
		mmDecrementRoomQuota.mock.t.Fatalf("AvailabilityRepositoryMock.DecrementRoomQuota mock is already set by Set")
	}

	expectation := &AvailabilityRepositoryMockDecrementRoomQuotaExpectation{
		mock:               mmDecrementRoomQuota.mock,
		params:             &AvailabilityRepositoryMockDecrementRoomQuotaParams{ctx, hotelID, roomID, date},
		expectationOrigins: AvailabilityRepositoryMockDecrementRoomQuotaExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDecrementRoomQuota.expectations = append(mmDecrementRoomQuota.expectations, expectation)
	return expectation
}

// Then sets up AvailabilityRepository.DecrementRoomQuota return parameters for the expectation previously defined by the When method
func (e *AvailabilityRepositoryMockDecrementRoomQuotaExpectation) Then(err error) *AvailabilityRepositoryMock {
	e.results = &AvailabilityRepositoryMockDecrementRoomQuotaResults{err}
	return e.mock
}

// Times sets number of times AvailabilityRepository.DecrementRoomQuota should be invoked
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) Times(n uint64) *mAvailabilityRepositoryMockDecrementRoomQuota {
	if n == 0 {
		mmDecrementRoomQuota.mock.t.Fatalf("Times of AvailabilityRepositoryMock.DecrementRoomQuota mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDecrementRoomQuota.expectedInvocations, n)
	mmDecrementRoomQuota.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDecrementRoomQuota
}

func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) invocationsDone() bool {
	if len(mmDecrementRoomQuota.expectations) == 0 && mmDecrementRoomQuota.defaultExpectation == nil && mmDecrementRoomQuota.mock.funcDecrementRoomQuota == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDecrementRoomQuota.mock.afterDecrementRoomQuotaCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDecrementRoomQuota.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DecrementRoomQuota implements mm_service.AvailabilityRepository
func (mmDecrementRoomQuota *AvailabilityRepositoryMock) DecrementRoomQuota(ctx context.Context, hotelID string, roomID string, date []time.Time) (err error) {
	mm_atomic.AddUint64(&mmDecrementRoomQuota.beforeDecrementRoomQuotaCounter, 1)
	defer mm_atomic.AddUint64(&mmDecrementRoomQuota.afterDecrementRoomQuotaCounter, 1)

	mmDecrementRoomQuota.t.Helper()

	if mmDecrementRoomQuota.inspectFuncDecrementRoomQuota != nil {
		mmDecrementRoomQuota.inspectFuncDecrementRoomQuota(ctx, hotelID, roomID, date)
	}

	mm_params := AvailabilityRepositoryMockDecrementRoomQuotaParams{ctx, hotelID, roomID, date}

	// Record call args
	mmDecrementRoomQuota.DecrementRoomQuotaMock.mutex.Lock()
	mmDecrementRoomQuota.DecrementRoomQuotaMock.callArgs = append(mmDecrementRoomQuota.DecrementRoomQuotaMock.callArgs, &mm_params)
	mmDecrementRoomQuota.DecrementRoomQuotaMock.mutex.Unlock()

	for _, e := range mmDecrementRoomQuota.DecrementRoomQuotaMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.Counter, 1)
		mm_want := mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.params
		mm_want_ptrs := mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.paramPtrs

		mm_got := AvailabilityRepositoryMockDecrementRoomQuotaParams{ctx, hotelID, roomID, date}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDecrementRoomQuota.t.Errorf("AvailabilityRepositoryMock.DecrementRoomQuota got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.hotelID != nil && !minimock.Equal(*mm_want_ptrs.hotelID, mm_got.hotelID) {
				mmDecrementRoomQuota.t.Errorf("AvailabilityRepositoryMock.DecrementRoomQuota got unexpected parameter hotelID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.expectationOrigins.originHotelID, *mm_want_ptrs.hotelID, mm_got.hotelID, minimock.Diff(*mm_want_ptrs.hotelID, mm_got.hotelID))
			}

			if mm_want_ptrs.roomID != nil && !minimock.Equal(*mm_want_ptrs.roomID, mm_got.roomID) {
				mmDecrementRoomQuota.t.Errorf("AvailabilityRepositoryMock.DecrementRoomQuota got unexpected parameter roomID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.expectationOrigins.originRoomID, *mm_want_ptrs.roomID, mm_got.roomID, minimock.Diff(*mm_want_ptrs.roomID, mm_got.roomID))
			}

			if mm_want_ptrs.date != nil && !minimock.Equal(*mm_want_ptrs.date, mm_got.date) {
				mmDecrementRoomQuota.t.Errorf("AvailabilityRepositoryMock.DecrementRoomQuota got unexpected parameter date, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.expectationOrigins.originDate, *mm_want_ptrs.date, mm_got.date, minimock.Diff(*mm_want_ptrs.date, mm_got.date))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecrementRoomQuota.t.Errorf("AvailabilityRepositoryMock.DecrementRoomQuota got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecrementRoomQuota.DecrementRoomQuotaMock.defaultExpectation.results
		if mm_results == nil {
			mmDecrementRoomQuota.t.Fatal("No results are set for the AvailabilityRepositoryMock.DecrementRoomQuota")
		}
		return (*mm_results).err
	}
	if mmDecrementRoomQuota.funcDecrementRoomQuota != nil {
		return mmDecrementRoomQuota.funcDecrementRoomQuota(ctx, hotelID, roomID, date)
	}
	mmDecrementRoomQuota.t.Fatalf("Unexpected call to AvailabilityRepositoryMock.DecrementRoomQuota. %v %v %v %v", ctx, hotelID, roomID, date)
	return
}

// DecrementRoomQuotaAfterCounter returns a count of finished AvailabilityRepositoryMock.DecrementRoomQuota invocations
func (mmDecrementRoomQuota *AvailabilityRepositoryMock) DecrementRoomQuotaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecrementRoomQuota.afterDecrementRoomQuotaCounter)
}

// DecrementRoomQuotaBeforeCounter returns a count of AvailabilityRepositoryMock.DecrementRoomQuota invocations
func (mmDecrementRoomQuota *AvailabilityRepositoryMock) DecrementRoomQuotaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecrementRoomQuota.beforeDecrementRoomQuotaCounter)
}

// Calls returns a list of arguments used in each call to AvailabilityRepositoryMock.DecrementRoomQuota.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecrementRoomQuota *mAvailabilityRepositoryMockDecrementRoomQuota) Calls() []*AvailabilityRepositoryMockDecrementRoomQuotaParams {
	mmDecrementRoomQuota.mutex.RLock()

	argCopy := make([]*AvailabilityRepositoryMockDecrementRoomQuotaParams, len(mmDecrementRoomQuota.callArgs))
	copy(argCopy, mmDecrementRoomQuota.callArgs)

	mmDecrementRoomQuota.mutex.RUnlock()

	return argCopy
}

// MinimockDecrementRoomQuotaDone returns true if the count of the DecrementRoomQuota invocations corresponds
// the number of defined expectations
func (m *AvailabilityRepositoryMock) MinimockDecrementRoomQuotaDone() bool {
	if m.DecrementRoomQuotaMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DecrementRoomQuotaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DecrementRoomQuotaMock.invocationsDone()
}

// MinimockDecrementRoomQuotaInspect logs each unmet expectation
func (m *AvailabilityRepositoryMock) MinimockDecrementRoomQuotaInspect() {
	for _, e := range m.DecrementRoomQuotaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AvailabilityRepositoryMock.DecrementRoomQuota at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDecrementRoomQuotaCounter := mm_atomic.LoadUint64(&m.afterDecrementRoomQuotaCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DecrementRoomQuotaMock.defaultExpectation != nil && afterDecrementRoomQuotaCounter < 1 {
		if m.DecrementRoomQuotaMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AvailabilityRepositoryMock.DecrementRoomQuota at\n%s", m.DecrementRoomQuotaMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AvailabilityRepositoryMock.DecrementRoomQuota at\n%s with params: %#v", m.DecrementRoomQuotaMock.defaultExpectation.expectationOrigins.origin, *m.DecrementRoomQuotaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecrementRoomQuota != nil && afterDecrementRoomQuotaCounter < 1 {
		m.t.Errorf("Expected call to AvailabilityRepositoryMock.DecrementRoomQuota at\n%s", m.funcDecrementRoomQuotaOrigin)
	}

	if !m.DecrementRoomQuotaMock.invocationsDone() && afterDecrementRoomQuotaCounter > 0 {
		m.t.Errorf("Expected %d calls to AvailabilityRepositoryMock.DecrementRoomQuota at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DecrementRoomQuotaMock.expectedInvocations), m.DecrementRoomQuotaMock.expectedInvocationsOrigin, afterDecrementRoomQuotaCounter)
	}
}

type mAvailabilityRepositoryMockGetRoomAvailability struct {
	optional           bool
	mock               *AvailabilityRepositoryMock
	defaultExpectation *AvailabilityRepositoryMockGetRoomAvailabilityExpectation
	expectations       []*AvailabilityRepositoryMockGetRoomAvailabilityExpectation

	callArgs []*AvailabilityRepositoryMockGetRoomAvailabilityParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AvailabilityRepositoryMockGetRoomAvailabilityExpectation specifies expectation struct of the AvailabilityRepository.GetRoomAvailability
type AvailabilityRepositoryMockGetRoomAvailabilityExpectation struct {
	mock               *AvailabilityRepositoryMock
	params             *AvailabilityRepositoryMockGetRoomAvailabilityParams
	paramPtrs          *AvailabilityRepositoryMockGetRoomAvailabilityParamPtrs
	expectationOrigins AvailabilityRepositoryMockGetRoomAvailabilityExpectationOrigins
	results            *AvailabilityRepositoryMockGetRoomAvailabilityResults
	returnOrigin       string
	Counter            uint64
}

// AvailabilityRepositoryMockGetRoomAvailabilityParams contains parameters of the AvailabilityRepository.GetRoomAvailability
type AvailabilityRepositoryMockGetRoomAvailabilityParams struct {
	ctx     context.Context
	hotelID string
	roomID  string
}

// AvailabilityRepositoryMockGetRoomAvailabilityParamPtrs contains pointers to parameters of the AvailabilityRepository.GetRoomAvailability
type AvailabilityRepositoryMockGetRoomAvailabilityParamPtrs struct {
	ctx     *context.Context
	hotelID *string
	roomID  *string
}

// AvailabilityRepositoryMockGetRoomAvailabilityResults contains results of the AvailabilityRepository.GetRoomAvailability
type AvailabilityRepositoryMockGetRoomAvailabilityResults struct {
	d1  model.DateQuotaMap
	err error
}

// AvailabilityRepositoryMockGetRoomAvailabilityOrigins contains origins of expectations of the AvailabilityRepository.GetRoomAvailability
type AvailabilityRepositoryMockGetRoomAvailabilityExpectationOrigins struct {
	origin        string
	originCtx     string
	originHotelID string
	originRoomID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) Optional() *mAvailabilityRepositoryMockGetRoomAvailability {
	mmGetRoomAvailability.optional = true
	return mmGetRoomAvailability
}

// Expect sets up expected params for AvailabilityRepository.GetRoomAvailability
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) Expect(ctx context.Context, hotelID string, roomID string) *mAvailabilityRepositoryMockGetRoomAvailability {
	if mmGetRoomAvailability.mock.funcGetRoomAvailability != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Set")
	}

	if mmGetRoomAvailability.defaultExpectation == nil {
		mmGetRoomAvailability.defaultExpectation = &AvailabilityRepositoryMockGetRoomAvailabilityExpectation{}
	}

	if mmGetRoomAvailability.defaultExpectation.paramPtrs != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by ExpectParams functions")
	}

	mmGetRoomAvailability.defaultExpectation.params = &AvailabilityRepositoryMockGetRoomAvailabilityParams{ctx, hotelID, roomID}
	mmGetRoomAvailability.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRoomAvailability.expectations {
		if minimock.Equal(e.params, mmGetRoomAvailability.defaultExpectation.params) {
			mmGetRoomAvailability.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRoomAvailability.defaultExpectation.params)
		}
	}

	return mmGetRoomAvailability
}

// ExpectCtxParam1 sets up expected param ctx for AvailabilityRepository.GetRoomAvailability
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) ExpectCtxParam1(ctx context.Context) *mAvailabilityRepositoryMockGetRoomAvailability {
	if mmGetRoomAvailability.mock.funcGetRoomAvailability != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Set")
	}

	if mmGetRoomAvailability.defaultExpectation == nil {
		mmGetRoomAvailability.defaultExpectation = &AvailabilityRepositoryMockGetRoomAvailabilityExpectation{}
	}

	if mmGetRoomAvailability.defaultExpectation.params != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Expect")
	}

	if mmGetRoomAvailability.defaultExpectation.paramPtrs == nil {
		mmGetRoomAvailability.defaultExpectation.paramPtrs = &AvailabilityRepositoryMockGetRoomAvailabilityParamPtrs{}
	}
	mmGetRoomAvailability.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRoomAvailability.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRoomAvailability
}

// ExpectHotelIDParam2 sets up expected param hotelID for AvailabilityRepository.GetRoomAvailability
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) ExpectHotelIDParam2(hotelID string) *mAvailabilityRepositoryMockGetRoomAvailability {
	if mmGetRoomAvailability.mock.funcGetRoomAvailability != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Set")
	}

	if mmGetRoomAvailability.defaultExpectation == nil {
		mmGetRoomAvailability.defaultExpectation = &AvailabilityRepositoryMockGetRoomAvailabilityExpectation{}
	}

	if mmGetRoomAvailability.defaultExpectation.params != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Expect")
	}

	if mmGetRoomAvailability.defaultExpectation.paramPtrs == nil {
		mmGetRoomAvailability.defaultExpectation.paramPtrs = &AvailabilityRepositoryMockGetRoomAvailabilityParamPtrs{}
	}
	mmGetRoomAvailability.defaultExpectation.paramPtrs.hotelID = &hotelID
	mmGetRoomAvailability.defaultExpectation.expectationOrigins.originHotelID = minimock.CallerInfo(1)

	return mmGetRoomAvailability
}

// ExpectRoomIDParam3 sets up expected param roomID for AvailabilityRepository.GetRoomAvailability
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) ExpectRoomIDParam3(roomID string) *mAvailabilityRepositoryMockGetRoomAvailability {
	if mmGetRoomAvailability.mock.funcGetRoomAvailability != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Set")
	}

	if mmGetRoomAvailability.defaultExpectation == nil {
		mmGetRoomAvailability.defaultExpectation = &AvailabilityRepositoryMockGetRoomAvailabilityExpectation{}
	}

	if mmGetRoomAvailability.defaultExpectation.params != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Expect")
	}

	if mmGetRoomAvailability.defaultExpectation.paramPtrs == nil {
		mmGetRoomAvailability.defaultExpectation.paramPtrs = &AvailabilityRepositoryMockGetRoomAvailabilityParamPtrs{}
	}
	mmGetRoomAvailability.defaultExpectation.paramPtrs.roomID = &roomID
	mmGetRoomAvailability.defaultExpectation.expectationOrigins.originRoomID = minimock.CallerInfo(1)

	return mmGetRoomAvailability
}

// Inspect accepts an inspector function that has same arguments as the AvailabilityRepository.GetRoomAvailability
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) Inspect(f func(ctx context.Context, hotelID string, roomID string)) *mAvailabilityRepositoryMockGetRoomAvailability {
	if mmGetRoomAvailability.mock.inspectFuncGetRoomAvailability != nil {
		mmGetRoomAvailability.mock.t.Fatalf("Inspect function is already set for AvailabilityRepositoryMock.GetRoomAvailability")
	}

	mmGetRoomAvailability.mock.inspectFuncGetRoomAvailability = f

	return mmGetRoomAvailability
}

// Return sets up results that will be returned by AvailabilityRepository.GetRoomAvailability
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) Return(d1 model.DateQuotaMap, err error) *AvailabilityRepositoryMock {
	if mmGetRoomAvailability.mock.funcGetRoomAvailability != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Set")
	}

	if mmGetRoomAvailability.defaultExpectation == nil {
		mmGetRoomAvailability.defaultExpectation = &AvailabilityRepositoryMockGetRoomAvailabilityExpectation{mock: mmGetRoomAvailability.mock}
	}
	mmGetRoomAvailability.defaultExpectation.results = &AvailabilityRepositoryMockGetRoomAvailabilityResults{d1, err}
	mmGetRoomAvailability.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRoomAvailability.mock
}

// Set uses given function f to mock the AvailabilityRepository.GetRoomAvailability method
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) Set(f func(ctx context.Context, hotelID string, roomID string) (d1 model.DateQuotaMap, err error)) *AvailabilityRepositoryMock {
	if mmGetRoomAvailability.defaultExpectation != nil {
		mmGetRoomAvailability.mock.t.Fatalf("Default expectation is already set for the AvailabilityRepository.GetRoomAvailability method")
	}

	if len(mmGetRoomAvailability.expectations) > 0 {
		mmGetRoomAvailability.mock.t.Fatalf("Some expectations are already set for the AvailabilityRepository.GetRoomAvailability method")
	}

	mmGetRoomAvailability.mock.funcGetRoomAvailability = f
	mmGetRoomAvailability.mock.funcGetRoomAvailabilityOrigin = minimock.CallerInfo(1)
	return mmGetRoomAvailability.mock
}

// When sets expectation for the AvailabilityRepository.GetRoomAvailability which will trigger the result defined by the following
// Then helper
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) When(ctx context.Context, hotelID string, roomID string) *AvailabilityRepositoryMockGetRoomAvailabilityExpectation {
	if mmGetRoomAvailability.mock.funcGetRoomAvailability != nil {
		mmGetRoomAvailability.mock.t.Fatalf("AvailabilityRepositoryMock.GetRoomAvailability mock is already set by Set")
	}

	expectation := &AvailabilityRepositoryMockGetRoomAvailabilityExpectation{
		mock:               mmGetRoomAvailability.mock,
		params:             &AvailabilityRepositoryMockGetRoomAvailabilityParams{ctx, hotelID, roomID},
		expectationOrigins: AvailabilityRepositoryMockGetRoomAvailabilityExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRoomAvailability.expectations = append(mmGetRoomAvailability.expectations, expectation)
	return expectation
}

// Then sets up AvailabilityRepository.GetRoomAvailability return parameters for the expectation previously defined by the When method
func (e *AvailabilityRepositoryMockGetRoomAvailabilityExpectation) Then(d1 model.DateQuotaMap, err error) *AvailabilityRepositoryMock {
	e.results = &AvailabilityRepositoryMockGetRoomAvailabilityResults{d1, err}
	return e.mock
}

// Times sets number of times AvailabilityRepository.GetRoomAvailability should be invoked
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) Times(n uint64) *mAvailabilityRepositoryMockGetRoomAvailability {
	if n == 0 {
		mmGetRoomAvailability.mock.t.Fatalf("Times of AvailabilityRepositoryMock.GetRoomAvailability mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRoomAvailability.expectedInvocations, n)
	mmGetRoomAvailability.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRoomAvailability
}

func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) invocationsDone() bool {
	if len(mmGetRoomAvailability.expectations) == 0 && mmGetRoomAvailability.defaultExpectation == nil && mmGetRoomAvailability.mock.funcGetRoomAvailability == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRoomAvailability.mock.afterGetRoomAvailabilityCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRoomAvailability.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRoomAvailability implements mm_service.AvailabilityRepository
func (mmGetRoomAvailability *AvailabilityRepositoryMock) GetRoomAvailability(ctx context.Context, hotelID string, roomID string) (d1 model.DateQuotaMap, err error) {
	mm_atomic.AddUint64(&mmGetRoomAvailability.beforeGetRoomAvailabilityCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRoomAvailability.afterGetRoomAvailabilityCounter, 1)

	mmGetRoomAvailability.t.Helper()

	if mmGetRoomAvailability.inspectFuncGetRoomAvailability != nil {
		mmGetRoomAvailability.inspectFuncGetRoomAvailability(ctx, hotelID, roomID)
	}

	mm_params := AvailabilityRepositoryMockGetRoomAvailabilityParams{ctx, hotelID, roomID}

	// Record call args
	mmGetRoomAvailability.GetRoomAvailabilityMock.mutex.Lock()
	mmGetRoomAvailability.GetRoomAvailabilityMock.callArgs = append(mmGetRoomAvailability.GetRoomAvailabilityMock.callArgs, &mm_params)
	mmGetRoomAvailability.GetRoomAvailabilityMock.mutex.Unlock()

	for _, e := range mmGetRoomAvailability.GetRoomAvailabilityMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.d1, e.results.err
		}
	}

	if mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.params
		mm_want_ptrs := mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.paramPtrs

		mm_got := AvailabilityRepositoryMockGetRoomAvailabilityParams{ctx, hotelID, roomID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRoomAvailability.t.Errorf("AvailabilityRepositoryMock.GetRoomAvailability got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.hotelID != nil && !minimock.Equal(*mm_want_ptrs.hotelID, mm_got.hotelID) {
				mmGetRoomAvailability.t.Errorf("AvailabilityRepositoryMock.GetRoomAvailability got unexpected parameter hotelID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.expectationOrigins.originHotelID, *mm_want_ptrs.hotelID, mm_got.hotelID, minimock.Diff(*mm_want_ptrs.hotelID, mm_got.hotelID))
			}

			if mm_want_ptrs.roomID != nil && !minimock.Equal(*mm_want_ptrs.roomID, mm_got.roomID) {
				mmGetRoomAvailability.t.Errorf("AvailabilityRepositoryMock.GetRoomAvailability got unexpected parameter roomID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.expectationOrigins.originRoomID, *mm_want_ptrs.roomID, mm_got.roomID, minimock.Diff(*mm_want_ptrs.roomID, mm_got.roomID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRoomAvailability.t.Errorf("AvailabilityRepositoryMock.GetRoomAvailability got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRoomAvailability.GetRoomAvailabilityMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRoomAvailability.t.Fatal("No results are set for the AvailabilityRepositoryMock.GetRoomAvailability")
		}
		return (*mm_results).d1, (*mm_results).err
	}
	if mmGetRoomAvailability.funcGetRoomAvailability != nil {
		return mmGetRoomAvailability.funcGetRoomAvailability(ctx, hotelID, roomID)
	}
	mmGetRoomAvailability.t.Fatalf("Unexpected call to AvailabilityRepositoryMock.GetRoomAvailability. %v %v %v", ctx, hotelID, roomID)
	return
}

// GetRoomAvailabilityAfterCounter returns a count of finished AvailabilityRepositoryMock.GetRoomAvailability invocations
func (mmGetRoomAvailability *AvailabilityRepositoryMock) GetRoomAvailabilityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoomAvailability.afterGetRoomAvailabilityCounter)
}

// GetRoomAvailabilityBeforeCounter returns a count of AvailabilityRepositoryMock.GetRoomAvailability invocations
func (mmGetRoomAvailability *AvailabilityRepositoryMock) GetRoomAvailabilityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoomAvailability.beforeGetRoomAvailabilityCounter)
}

// Calls returns a list of arguments used in each call to AvailabilityRepositoryMock.GetRoomAvailability.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRoomAvailability *mAvailabilityRepositoryMockGetRoomAvailability) Calls() []*AvailabilityRepositoryMockGetRoomAvailabilityParams {
	mmGetRoomAvailability.mutex.RLock()

	argCopy := make([]*AvailabilityRepositoryMockGetRoomAvailabilityParams, len(mmGetRoomAvailability.callArgs))
	copy(argCopy, mmGetRoomAvailability.callArgs)

	mmGetRoomAvailability.mutex.RUnlock()

	return argCopy
}

// MinimockGetRoomAvailabilityDone returns true if the count of the GetRoomAvailability invocations corresponds
// the number of defined expectations
func (m *AvailabilityRepositoryMock) MinimockGetRoomAvailabilityDone() bool {
	if m.GetRoomAvailabilityMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRoomAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRoomAvailabilityMock.invocationsDone()
}

// MinimockGetRoomAvailabilityInspect logs each unmet expectation
func (m *AvailabilityRepositoryMock) MinimockGetRoomAvailabilityInspect() {
	for _, e := range m.GetRoomAvailabilityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AvailabilityRepositoryMock.GetRoomAvailability at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRoomAvailabilityCounter := mm_atomic.LoadUint64(&m.afterGetRoomAvailabilityCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoomAvailabilityMock.defaultExpectation != nil && afterGetRoomAvailabilityCounter < 1 {
		if m.GetRoomAvailabilityMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AvailabilityRepositoryMock.GetRoomAvailability at\n%s", m.GetRoomAvailabilityMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AvailabilityRepositoryMock.GetRoomAvailability at\n%s with params: %#v", m.GetRoomAvailabilityMock.defaultExpectation.expectationOrigins.origin, *m.GetRoomAvailabilityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRoomAvailability != nil && afterGetRoomAvailabilityCounter < 1 {
		m.t.Errorf("Expected call to AvailabilityRepositoryMock.GetRoomAvailability at\n%s", m.funcGetRoomAvailabilityOrigin)
	}

	if !m.GetRoomAvailabilityMock.invocationsDone() && afterGetRoomAvailabilityCounter > 0 {
		m.t.Errorf("Expected %d calls to AvailabilityRepositoryMock.GetRoomAvailability at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRoomAvailabilityMock.expectedInvocations), m.GetRoomAvailabilityMock.expectedInvocationsOrigin, afterGetRoomAvailabilityCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AvailabilityRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDecrementRoomQuotaInspect()

			m.MinimockGetRoomAvailabilityInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AvailabilityRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AvailabilityRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDecrementRoomQuotaDone() &&
		m.MinimockGetRoomAvailabilityDone()
}
